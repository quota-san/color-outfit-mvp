<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Color Outfit Suggest (MVP)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:16px;}
    .wrap{position:relative; width:100%; max-width:520px;}
    video, canvas.display{width:100%; max-width:520px; border-radius:12px; background:#111; display:block;}
    canvas.overlay{position:absolute; inset:0; pointer-events:none; border-radius:12px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; align-items:center;}
    button{padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
    select{padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
    .hint{color:#555; font-size:13px; line-height:1.4; margin-top:6px;}
    .mini{color:#666; font-size:12px;}
    .swatch{width:140px; border-radius:12px; padding:10px; border:1px solid #ddd;}
    .chip{height:48px; border-radius:10px; border:1px solid rgba(0,0,0,.08);}
    .modeBadge{display:inline-block; padding:3px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; color:#444;}
  </style>
</head>
<body>
  <h2>撮影→スポイト色→配色提案（MVP）</h2>
  <div class="hint">
    ①「カメラ開始」→ライブ表示<br/>
    ②「撮影」→静止画を表示（その上でタップ＝スポイト）<br/>
    ③もう一度「撮影」→ライブ表示に戻る（次の撮影準備）
  </div>

  <div class="wrap">
    <video id="v" playsinline autoplay></video>
    <canvas id="photo" class="display"></canvas>
    <canvas id="mark" class="overlay"></canvas>
  </div>

  <div class="row">
    <button id="start">カメラ開始</button>
    <button id="snap">撮影</button>

    <select id="tpo">
      <option value="work">仕事</option>
      <option value="casual">休日</option>
      <option value="dinner">ディナー</option>
    </select>

    <span id="mode" class="modeBadge">未開始</span>
    <span id="picked" class="mini"></span>
  </div>

  <div id="out" class="row"></div>

<script>
const v = document.getElementById('v');
const photo = document.getElementById('photo');
const mark = document.getElementById('mark');

const out = document.getElementById('out');
const picked = document.getElementById('picked');
const modeBadge = document.getElementById('mode');
const tpoSel = document.getElementById('tpo');

const photoCtx = photo.getContext('2d', { willReadFrequently: true });
const mctx = mark.getContext('2d');

// どれくらいの範囲で色を拾うか（NxN）
const SAMPLE_SIZE = 24;

// 表示状態
// live: video表示（スポイトは効くが、基本は撮影→freeze推奨）
// freeze: photo canvas表示（スポイト操作の本命）
let viewMode = "live"; // live | freeze
let streamRef = null;

let currentTpo = "work";
tpoSel.value = currentTpo;

// 直近の「ベース色」(RGB) を保持：TPO変更時に“提案色自体”を作り直すため
let lastBaseRgb = null;

// スポイト位置（photo座標）
let lastPick = null;

// TPO別：6色の支配率（合計100%）
const TPO_WEIGHTS = {
  work:   [60, 18, 12,  4,  3,  3],
  casual: [45, 18, 12, 12,  7,  6],
  dinner: [35, 12,  8, 25, 10, 10],
};

function setMode(mode){
  viewMode = mode;
  if(mode === "live"){
    v.style.display = "block";
    photo.style.display = "none";
    modeBadge.textContent = "ライブ";
    clearMarker();
  }else{
    v.style.display = "none";
    photo.style.display = "block";
    modeBadge.textContent = "静止画";
    // マーカーは維持（lastPickがあれば再描画）
    if(lastPick) drawMarker(lastPick.x, lastPick.y, photo.width, photo.height);
  }
}

// 初期は静止画キャンバスを隠す
photo.style.display = "none";
setMode("live");

// カメラ開始
document.getElementById('start').onclick = async () => {
  try{
    if(streamRef){
      // 既に起動済みならそのまま
      setMode("live");
      picked.textContent = "カメラは起動済みです。";
      return;
    }

    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" }, audio: false
    });
    streamRef = stream;
    v.srcObject = stream;

    // iOS対策：明示 play
    await v.play();

    setMode("live");
    picked.textContent = "カメラ起動中。撮影で静止画に固定できます。";
  }catch(err){
    picked.textContent = "カメラ開始に失敗: " + (err?.name ?? err);
    console.error(err);
  }
};

// 撮影ボタン：live→freeze(撮影) / freeze→live(戻る)
document.getElementById('snap').onclick = () => {
  if(!streamRef){
    picked.textContent = "先に「カメラ開始」を押してください。";
    return;
  }

  if(viewMode === "live"){
    // 撮影して静止画へ
    const info = drawVideoToPhotoSquare(520);
    if(!info) return;

    setMode("freeze");

    // 未タップなら中心を採用して提案しておく
    const x = lastPick ? lastPick.x : Math.floor(photo.width/2);
    const y = lastPick ? lastPick.y : Math.floor(photo.height/2);
    lastPick = {x, y};

    const base = medianColorAt(photoCtx, x, y, SAMPLE_SIZE, photo.width, photo.height);
    lastBaseRgb = base;
    const hex = rgbToHex(...base);

    picked.textContent = `採用: (${x},${y}) 周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${hex}`;
    drawMarker(x, y, photo.width, photo.height);

    const palette = suggestPalette(base, currentTpo);
    renderSwatches(palette, currentTpo);
  }else{
    // 静止画をやめてライブへ戻る
    setMode("live");
    picked.textContent = "ライブに戻りました。構図を決めて「撮影」で固定できます。";
  }
};

// TPO変更：提案色そのものを作り直す
tpoSel.addEventListener('change', () => {
  currentTpo = tpoSel.value;

  if(lastBaseRgb){
    const palette = suggestPalette(lastBaseRgb, currentTpo);
    renderSwatches(palette, currentTpo);
    picked.textContent = (picked.textContent || "") + "（TPOで提案色を更新）";
  }
}, {passive:true});

// ========== 色変換 ==========
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h=0, s=0, l=(max+min)/2;
  const d=max-min;
  if(d!==0){
    s = d / (1 - Math.abs(2*l - 1));
    switch(max){
      case r: h = ((g-b)/d) % 6; break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h *= 60; if(h<0) h+=360;
  }
  return [h,s,l];
}
function hslToRgb(h,s,l){
  const C = (1 - Math.abs(2*l - 1)) * s;
  const X = C * (1 - Math.abs((h/60)%2 - 1));
  const m = l - C/2;
  let r1=0,g1=0,b1=0;
  if(0<=h && h<60){ r1=C; g1=X; }
  else if(60<=h && h<120){ r1=X; g1=C; }
  else if(120<=h && h<180){ g1=C; b1=X; }
  else if(180<=h && h<240){ g1=X; b1=C; }
  else if(240<=h && h<300){ r1=X; b1=C; }
  else { r1=C; b1=X; }
  return [
    Math.round((r1+m)*255),
    Math.round((g1+m)*255),
    Math.round((b1+m)*255)
  ];
}
function rgbToHex(r,g,b){
  return "#" + [r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");
}

// ========== スポイト（中央値） ==========
function medianColorAt(ctx2d, x, y, n, imgW, imgH){
  const half = Math.floor(n/2);
  const left = Math.max(0, x - half);
  const top  = Math.max(0, y - half);
  const right = Math.min(imgW, x + half);
  const bottom = Math.min(imgH, y + half);
  const w = Math.max(1, right - left);
  const h = Math.max(1, bottom - top);

  const data = ctx2d.getImageData(left, top, w, h).data;
  const rs=[], gs=[], bs=[];
  for(let i=0;i<data.length;i+=4){
    const a = data[i+3];
    if(a < 230) continue;
    rs.push(data[i]); gs.push(data[i+1]); bs.push(data[i+2]);
  }
  if(rs.length===0) return [128,128,128];
  rs.sort((a,b)=>a-b); gs.sort((a,b)=>a-b); bs.sort((a,b)=>a-b);
  const mid = Math.floor(rs.length/2);
  return [rs[mid], gs[mid], bs[mid]];
}

// ========== 提案色生成（TPOで色自体を変える） ==========
function suggestPalette(baseRgb, tpo){
  const [h0,s0,l0] = rgbToHsl(...baseRgb);

  // TPOで “色相の飛ばし方” と “彩度/明度の寄せ方” を変える
  // 6色構成は固定：Base / Var1 / Var2 / Var3 / Var4 / Var5
  // 仕事：同系中心＋穏やか（補色はかなり弱め）
  // 休日：同系＋補色＋分割（バランス）
  // ディナー：強めコントラスト（補色・トライアド寄りを増やす）
  let offsets, sMul, lBias;
  if(tpo === "work"){
    offsets = [0, +18, -18, +150, +165, +195]; // 補色を避けて“分割寄り”にする
    sMul = 0.70; lBias = 0.00;
  }else if(tpo === "casual"){
    offsets = [0, +20, -20, +180, +150, +210]; // 王道：補色＋分割補色
    sMul = 0.90; lBias = 0.02;
  }else{ // dinner
    offsets = [0, +30, -30, +180, +120, +240]; // 補色＋トライアド（夜は映える）
    sMul = 1.05; lBias = -0.03;
  }

  const mk = (label, hh, ss, ll) => {
    const rgb = hslToRgb((hh+360)%360, clamp01(ss), clamp01(ll));
    return {label, rgb, hex: rgbToHex(...rgb)};
  };

  // Baseはそのまま（ただしディナーは少し締める/仕事は少し落ち着かせる、なども可能）
  const base = mk("Base（拾った色）", h0, s0, l0);

  // バリエーション生成：彩度をTPOで寄せる + ちょい明度バイアス
  const s = clamp01(s0 * sMul);
  const l = clamp01(l0 + lBias);

  const v1 = mk("提案1", h0 + offsets[1], s, l);
  const v2 = mk("提案2", h0 + offsets[2], s, l);

  // 強い色は扱いが難しいので、仕事は特に彩度を落とす／ディナーは少し上げる
  const accentS = (tpo==="work") ? clamp01(Math.max(s0*0.55, 0.25)) :
                  (tpo==="dinner") ? clamp01(Math.max(s0*1.10, 0.50)) :
                                     clamp01(Math.max(s0*0.95, 0.40));
  const accentL = (tpo==="dinner") ? clamp01(Math.min(l0+0.05, 0.62)) :
                  (tpo==="work") ? clamp01(Math.min(l0+0.02, 0.60)) :
                                   clamp01(Math.min(l0+0.04, 0.62));

  const v3 = mk("提案3（対比）", h0 + offsets[3], accentS, accentL);
  const v4 = mk("提案4（対比）", h0 + offsets[4], accentS, accentL);
  const v5 = mk("提案5（対比）", h0 + offsets[5], accentS, accentL);

  return [base, v1, v2, v3, v4, v5];
}

function renderSwatches(items, tpo){
  const weights = TPO_WEIGHTS[tpo] ?? TPO_WEIGHTS.work;

  out.innerHTML = "";
  items.forEach((it, idx) => {
    const w = weights[idx] ?? 0;
    const div = document.createElement('div');
    div.className = "swatch";
    div.innerHTML = `
      <div class="chip" style="background:${it.hex}"></div>
      <div style="margin-top:8px;font-size:13px;">
        ${it.label} <b>${w}%</b>
      </div>
      <div style="color:#555;font-size:12px;">${it.hex}</div>
    `;
    out.appendChild(div);
  });
}

// ========== 描画：video→photoへ撮影（正方形） ==========
function drawVideoToPhotoSquare(targetSize=520){
  const vw = v.videoWidth, vh = v.videoHeight;
  if(!vw || !vh){
    picked.textContent = "カメラの準備中です（数秒待って再度）。";
    return null;
  }
  photo.width = targetSize;
  photo.height = targetSize;

  const side = Math.min(vw, vh);
  const sx = Math.floor(vw/2 - side/2);
  const sy = Math.floor(vh/2 - side/2);

  photoCtx.drawImage(v, sx, sy, side, side, 0, 0, targetSize, targetSize);
  return {w: targetSize, h: targetSize};
}

// ========== マーカー ==========
function clearMarker(){
  resizeOverlayToMatchDisplay();
  const rect = getDisplayRect();
  mctx.clearRect(0,0,rect.w,rect.h);
}

function getDisplayRect(){
  // いま見えている表示要素（video or photo）の表示サイズ
  const el = (viewMode === "freeze") ? photo : v;
  const r = el.getBoundingClientRect();
  return {w: r.width, h: r.height};
}

function resizeOverlayToMatchDisplay(){
  const rect = getDisplayRect();
  mark.width = Math.round(rect.w * devicePixelRatio);
  mark.height = Math.round(rect.h * devicePixelRatio);
  mctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}

function drawMarker(x, y, w, h){
  resizeOverlayToMatchDisplay();
  const rect = getDisplayRect();

  mctx.clearRect(0,0,rect.w,rect.h);

  const px = (x / w) * rect.w;
  const py = (y / h) * rect.h;

  // 十字
  mctx.lineWidth = 2;
  mctx.strokeStyle = "rgba(255,255,255,0.9)";
  mctx.beginPath();
  mctx.moveTo(px-12, py); mctx.lineTo(px+12, py);
  mctx.moveTo(px, py-12); mctx.lineTo(px, py+12);
  mctx.stroke();

  // サンプル枠
  const boxW = (SAMPLE_SIZE / w) * rect.w;
  const boxH = (SAMPLE_SIZE / h) * rect.h;
  mctx.strokeStyle = "rgba(255,255,255,0.6)";
  mctx.lineWidth = 1.5;
  mctx.strokeRect(px - boxW/2, py - boxH/2, boxW, boxH);
}

// ========== スポイト：静止画上でタップ（pointerdown一本化） ==========
photo.addEventListener('pointerdown', (e) => {
  if(viewMode !== "freeze") return;

  const rect = photo.getBoundingClientRect();
  const rx = clamp01((e.clientX - rect.left) / rect.width);
  const ry = clamp01((e.clientY - rect.top) / rect.height);

  const x = Math.round(rx * (photo.width - 1));
  const y = Math.round(ry * (photo.height - 1));

  lastPick = {x, y};

  const base = medianColorAt(photoCtx, x, y, SAMPLE_SIZE, photo.width, photo.height);
  lastBaseRgb = base;

  const hex = rgbToHex(...base);
  picked.textContent = `スポイト: (${x},${y}) 周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${hex}`;

  drawMarker(x, y, photo.width, photo.height);

  const palette = suggestPalette(base, currentTpo);
  renderSwatches(palette, currentTpo);
}, {passive:true});

// リサイズでマーカーずれ対策
window.addEventListener('resize', () => {
  if(viewMode === "freeze" && lastPick){
    drawMarker(lastPick.x, lastPick.y, photo.width, photo.height);
  }else{
    clearMarker();
  }
}, {passive:true});
</script>
</body>
</html>