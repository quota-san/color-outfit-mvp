<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Color Outfit Suggest (MVP)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:16px;}
    .wrap{position:relative; width:100%; max-width:520px;}
    video, canvas.display{width:100%; max-width:520px; border-radius:12px; background:#111; display:block;}
    canvas.overlay{position:absolute; inset:0; pointer-events:none; border-radius:12px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; align-items:center;}
    button{padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
    select{padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
    .hint{color:#555; font-size:13px; line-height:1.4; margin-top:6px;}
    .mini{color:#666; font-size:12px;}
    .swatch{
      width:160px; border-radius:12px; padding:10px; border:1px solid #ddd;
      user-select:none;
    }
    .swatch:active{transform:scale(0.99);}
    .chip{height:48px; border-radius:10px; border:1px solid rgba(0,0,0,.08);}
    .modeBadge{display:inline-block; padding:3px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; color:#444;}
    .cand{display:flex; gap:6px; margin-top:8px; flex-wrap:wrap;}
    .dot{width:18px; height:18px; border-radius:999px; border:1px solid rgba(0,0,0,.15);}
    .small{font-size:11px; color:#666; line-height:1.35;}
    .kbd{display:inline-block; padding:0 6px; border:1px solid #ddd; border-radius:6px; font-size:11px; color:#444;}
  </style>
</head>
<body>
  <h2>撮影→スポイト色→配色提案（MVP）</h2>
  <div class="hint">
    ①「カメラ開始」→ライブ表示<br/>
    ②「撮影」→静止画を表示（その上でタップ＝スポイト）<br/>
    ③もう一度「撮影」→ライブ表示に戻る（次の撮影準備）<br/>
    ④カードをタップすると、その枠の<b>服っぽい候補色（3つ）</b>を切り替えます（<span class="kbd">Tap</span>）。<br/>
    ※提案3〜5（対比）は「売ってる差し色」だけに限定。
  </div>

  <div class="wrap">
    <video id="v" playsinline autoplay></video>
    <canvas id="photo" class="display"></canvas>
    <canvas id="mark" class="overlay"></canvas>
  </div>

  <div class="row">
    <button id="start">カメラ開始</button>
    <button id="snap">撮影</button>

    <select id="tpo">
      <option value="work">仕事</option>
      <option value="casual">休日</option>
      <option value="dinner">ディナー</option>
    </select>

    <span id="mode" class="modeBadge">未開始</span>
    <span id="picked" class="mini"></span>
  </div>

  <!-- 占有率バー（100%） -->
  <div id="mixWrap" style="max-width:520px; margin-top:12px;">
    <div class="mini" style="margin-bottom:6px;">占有率イメージ（合計100%）</div>
    <div id="mixBar" style="display:flex; height:18px; border-radius:999px; overflow:hidden; border:1px solid #ddd;"></div>
    <div id="mixLegend" class="mini" style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap;"></div>
  </div>

  <div id="out" class="row"></div>

<script>
const v = document.getElementById('v');
const photo = document.getElementById('photo');
const mark = document.getElementById('mark');

const out = document.getElementById('out');
const picked = document.getElementById('picked');
const modeBadge = document.getElementById('mode');
const tpoSel = document.getElementById('tpo');

const photoCtx = photo.getContext('2d', { willReadFrequently: true });
const mctx = mark.getContext('2d');

const SAMPLE_SIZE = 24;

let viewMode = "live"; // live | freeze
let streamRef = null;

let currentTpo = "work";
tpoSel.value = currentTpo;

let lastBaseRgb = null;
let lastBaseHex = null;
let lastPick = null;

// 支配率（合計100%）
const TPO_WEIGHTS = {
  work:   [60, 18, 12,  4,  3,  3],
  casual: [45, 18, 12, 12,  7,  6],
  dinner: [35, 12,  8, 25, 10, 10],
};

// ====== トーン決め打ち（TPOごと） ======
const TONE_PRESET = {
  work: {
    name: "Muted / Middle",
    base:  { s:[0.10,0.35], l:[0.35,0.55] },
    same:  { s:[0.10,0.30], l:[0.35,0.55] },
    contra:{ s:[0.10,0.28], l:[0.35,0.55] },
    offsets: [0, +18, -18, +150, +165, +195]
  },
  casual: {
    name: "Medium / Flexible",
    base:  { s:[0.15,0.55], l:[0.30,0.70] },
    same:  { s:[0.15,0.55], l:[0.30,0.70] },
    contra:{ s:[0.25,0.65], l:[0.30,0.70] },
    offsets: [0, +20, -20, +180, +150, +210]
  },
  dinner: {
    name: "Contrast / Night",
    base:  { s:[0.20,0.60], l:[0.25,0.55] },
    same:  { s:[0.20,0.55], l:[0.25,0.55] },
    contra:{ s:[0.45,0.85], l:[0.22,0.55] },
    offsets: [0, +30, -30, +180, +120, +240]
  }
};

// ====== “服っぽい”定番色パレット ======
const APPAREL_PALETTE = [
  // neutrals
  {name:"Black", hex:"#111111"},
  {name:"Charcoal", hex:"#2b2b2b"},
  {name:"Gray", hex:"#808080"},
  {name:"Off White", hex:"#f2f0ea"},
  {name:"Ivory", hex:"#efe2c6"},
  {name:"Navy", hex:"#0f2546"},
  {name:"Denim", hex:"#2f5d8a"},

  // browns
  {name:"Dark Brown", hex:"#3a2a1f"},
  {name:"Camel", hex:"#c19a6b"},
  {name:"Taupe", hex:"#8b7d6b"},

  // greens
  {name:"Olive", hex:"#556b2f"},
  {name:"Forest", hex:"#1f3b2c"},
  {name:"Sage", hex:"#9caf88"},

  // accents (売ってる差し色枠)
  {name:"Burgundy", hex:"#5a1a28"},
  {name:"Terracotta", hex:"#b0503a"},
  {name:"Mustard", hex:"#b58b1b"},
  {name:"Teal", hex:"#0f6b6b"},
  {name:"Cobalt", hex:"#1f4fbf"},
  {name:"Plum", hex:"#4a2b5e"},
];

// 対比スロット（提案3〜5）は、この中だけに限定
// “売ってる差し色”を強めに：無彩色/ネイビー/デニム + ボルドー/マスタード/テラコッタ + ダークブラウン
const ACCENT_ONLY_NAMES = new Set([
  "Navy","Denim","Black","Charcoal","Off White",
  "Dark Brown",
  "Burgundy","Mustard","Terracotta",
  "Teal","Cobalt","Plum"
]);

const APPAREL = APPAREL_PALETTE.map(p => {
  const rgb = hexToRgb(p.hex);
  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
  return {...p, rgb, hsl};
});

const APPAREL_ACCENTS = APPAREL.filter(p => ACCENT_ONLY_NAMES.has(p.name));

// ====== スロット状態（候補3つ＋現在選択） ======
let slots = []; // [{label, weight, toneName, rawHex, options:[{name,hex}], selIndex}]

function setMode(mode){
  viewMode = mode;
  if(mode === "live"){
    v.style.display = "block";
    photo.style.display = "none";
    modeBadge.textContent = "ライブ";
    clearMarker();
  }else{
    v.style.display = "none";
    photo.style.display = "block";
    modeBadge.textContent = "静止画";
    if(lastPick) drawMarker(lastPick.x, lastPick.y, photo.width, photo.height);
  }
}

photo.style.display = "none";
setMode("live");

// ====== カメラ開始 ======
document.getElementById('start').onclick = async () => {
  try{
    if(streamRef){
      setMode("live");
      picked.textContent = "カメラは起動済みです。";
      return;
    }
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" }, audio: false
    });
    streamRef = stream;
    v.srcObject = stream;
    await v.play();
    setMode("live");
    picked.textContent = "カメラ起動中。撮影で静止画に固定できます。";
  }catch(err){
    picked.textContent = "カメラ開始に失敗: " + (err?.name ?? err);
    console.error(err);
  }
};

// ====== 撮影：live→freeze / freeze→live ======
document.getElementById('snap').onclick = () => {
  if(!streamRef){
    picked.textContent = "先に「カメラ開始」を押してください。";
    return;
  }

  if(viewMode === "live"){
    const info = drawVideoToPhotoSquare(520);
    if(!info) return;

    setMode("freeze");

    const x = lastPick ? lastPick.x : Math.floor(photo.width/2);
    const y = lastPick ? lastPick.y : Math.floor(photo.height/2);
    lastPick = {x, y};

    const base = medianColorAt(photoCtx, x, y, SAMPLE_SIZE, photo.width, photo.height);
    lastBaseRgb = base;
    lastBaseHex = rgbToHex(...base);

    picked.textContent = `採用: (${x},${y}) 周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${lastBaseHex}`;
    drawMarker(x, y, photo.width, photo.height);

    buildAndRenderFromBase(base);
  }else{
    setMode("live");
    picked.textContent = "ライブに戻りました。構図を決めて「撮影」で固定できます。";
  }
};

// ====== TPO変更：再生成 ======
tpoSel.addEventListener('change', () => {
  currentTpo = tpoSel.value;
  if(lastBaseRgb){
    buildAndRenderFromBase(lastBaseRgb);
  }
}, {passive:true});

// ====== 静止画上タップ：スポイト ======
photo.addEventListener('pointerdown', (e) => {
  if(viewMode !== "freeze") return;

  const rect = photo.getBoundingClientRect();
  const rx = clamp01((e.clientX - rect.left) / rect.width);
  const ry = clamp01((e.clientY - rect.top) / rect.height);

  const x = Math.round(rx * (photo.width - 1));
  const y = Math.round(ry * (photo.height - 1));

  lastPick = {x, y};

  const base = medianColorAt(photoCtx, x, y, SAMPLE_SIZE, photo.width, photo.height);
  lastBaseRgb = base;
  lastBaseHex = rgbToHex(...base);

  picked.textContent = `スポイト: (${x},${y}) 周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${lastBaseHex}`;
  drawMarker(x, y, photo.width, photo.height);

  buildAndRenderFromBase(base);
}, {passive:true});

// ====== リサイズ ======
window.addEventListener('resize', () => {
  if(viewMode === "freeze" && lastPick){
    drawMarker(lastPick.x, lastPick.y, photo.width, photo.height);
  }else{
    clearMarker();
  }
}, {passive:true});

// ====== Base→raw生成→スナップ（対比のみ差し色限定） ======
function buildAndRenderFromBase(baseRgb){
  const preset = TONE_PRESET[currentTpo] ?? TONE_PRESET.work;
  const weights = TPO_WEIGHTS[currentTpo] ?? TPO_WEIGHTS.work;

  const raw = suggestRawToneLocked(baseRgb, currentTpo);

  slots = raw.map((r, idx) => {
    const isContrast = idx >= 3; // 提案3〜5のみ
    const pool = isContrast ? APPAREL_ACCENTS : APPAREL;

    const options = nearestFromPool(r.rgb, pool, 3);

    return {
      label: r.label,
      weight: weights[idx] ?? 0,
      toneName: (idx===0 ? preset.name : ""),
      rawHex: r.hex,
      options,
      selIndex: 0
    };
  });

  renderSlots();
}

function renderSlots(){
  out.innerHTML = "";
  slots.forEach((s) => {
    const chosen = s.options[s.selIndex] ?? s.options[0];

    const div = document.createElement('div');
    div.className = "swatch";
    div.innerHTML = `
      <div class="chip" style="background:${chosen.hex}"></div>
      <div style="margin-top:8px;font-size:13px;">
        ${escapeHtml(s.label)} <b>${s.weight}%</b>
      </div>
      <div style="color:#555;font-size:12px;">
        ${escapeHtml(chosen.name)} ${chosen.hex}
      </div>
      <div class="small" style="margin-top:6px;">
        元（理論色）: ${s.rawHex}
        ${s.toneName ? `<div style="margin-top:4px;">Tone: ${escapeHtml(s.toneName)}</div>` : ``}
      </div>
      <div class="cand" aria-label="candidates">
        ${s.options.map((o,i)=>`<div class="dot" title="${escapeHtml(o.name)} ${o.hex}" style="background:${o.hex}; opacity:${i===s.selIndex?1:0.35};"></div>`).join("")}
      </div>
      <div class="small" style="margin-top:6px;">タップで候補切替</div>
    `;

    div.addEventListener('click', () => {
      if(!s.options || s.options.length===0) return;
      s.selIndex = (s.selIndex + 1) % s.options.length;
      renderSlots(); // 再描画（棒グラフも更新）
    }, {passive:true});

    out.appendChild(div);
  });

  renderMixBar(); // ←ここが棒グラフ更新
}

// ====== 占有率バー（100%） ======
function renderMixBar(){
  const bar = document.getElementById('mixBar');
  const legend = document.getElementById('mixLegend');
  if(!bar || !legend) return;

  bar.innerHTML = "";
  legend.innerHTML = "";

  for(const s of slots){
    const chosen = s.options[s.selIndex] ?? s.options[0];
    const w = Math.max(0, Number(s.weight) || 0);
    if(w <= 0) continue;

    const seg = document.createElement('div');
    seg.style.width = w + "%";
    seg.style.background = chosen.hex;
    bar.appendChild(seg);

    const item = document.createElement('div');
    item.style.display = "flex";
    item.style.alignItems = "center";
    item.style.gap = "6px";

    const dot = document.createElement('span');
    dot.style.width = "10px";
    dot.style.height = "10px";
    dot.style.borderRadius = "999px";
    dot.style.border = "1px solid rgba(0,0,0,.15)";
    dot.style.background = chosen.hex;

    const txt = document.createElement('span');
    txt.textContent = `${s.label}: ${w}%`;

    item.appendChild(dot);
    item.appendChild(txt);
    legend.appendChild(item);
  }
}

// ====== raw生成（トーン決め打ち） ======
function suggestRawToneLocked(baseRgb, tpo){
  const preset = TONE_PRESET[tpo] ?? TONE_PRESET.work;
  const [h0,s0,l0] = rgbToHsl(...baseRgb);

  const o = preset.offsets;

  const baseSL = toneLock(s0, l0, preset.base);
  const sameSL = toneLock(s0, l0, preset.same);
  const contraSL = toneLock(s0, l0, preset.contra);

  return [
    mkHsl("Base（拾った色）", h0 + o[0], baseSL[0],   baseSL[1]),
    mkHsl("提案1（同系）",    h0 + o[1], sameSL[0],   sameSL[1]),
    mkHsl("提案2（同系）",    h0 + o[2], sameSL[0],   sameSL[1]),
    mkHsl("提案3（対比）",    h0 + o[3], contraSL[0], contraSL[1]),
    mkHsl("提案4（対比）",    h0 + o[4], contraSL[0], contraSL[1]),
    mkHsl("提案5（対比）",    h0 + o[5], contraSL[0], contraSL[1]),
  ];
}

function toneLock(s, l, tone){
  return [ clamp(s, tone.s[0], tone.s[1]), clamp(l, tone.l[0], tone.l[1]) ];
}

function mkHsl(label, h, s, l){
  const rgb = hslToRgb((h+360)%360, clamp01(s), clamp01(l));
  return { label, rgb, hex: rgbToHex(rgb[0],rgb[1],rgb[2]) };
}

// ====== スナップ：指定プールから近傍k件 ======
function nearestFromPool(rgbArr, pool, k=3){
  const [r,g,b] = rgbArr;
  const hsl = rgbToHsl(r,g,b);

  const scored = pool.map(p => {
    const d = hslDistance(hsl, p.hsl);
    return { name:p.name, hex:p.hex, dist:d };
  });

  scored.sort((a,b)=>a.dist-b.dist);

  const out = [];
  const seen = new Set();
  for(const s of scored){
    if(seen.has(s.hex)) continue;
    seen.add(s.hex);
    out.push(s);
    if(out.length>=k) break;
  }
  return out;
}

// Hue重め＋Lも少し重め（服っぽい近さ）
function hslDistance(a, b){
  const [h1,s1,l1] = a;
  const [h2,s2,l2] = b;

  let dh = Math.abs(h1 - h2);
  dh = Math.min(dh, 360 - dh) / 180;
  const ds = Math.abs(s1 - s2);
  const dl = Math.abs(l1 - l2);

  const wH = 2.0, wS = 1.0, wL = 1.4;
  return (wH*dh)*(wH*dh) + (wS*ds)*(wS*ds) + (wL*dl)*(wL*dl);
}

// ====== 色変換ユーティリティ ======
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h=0, s=0, l=(max+min)/2;
  const d=max-min;
  if(d!==0){
    s = d / (1 - Math.abs(2*l - 1));
    switch(max){
      case r: h = ((g-b)/d) % 6; break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h *= 60; if(h<0) h+=360;
  }
  return [h,s,l];
}
function hslToRgb(h,s,l){
  const C = (1 - Math.abs(2*l - 1)) * s;
  const X = C * (1 - Math.abs((h/60)%2 - 1));
  const m = l - C/2;
  let r1=0,g1=0,b1=0;
  if(0<=h && h<60){ r1=C; g1=X; }
  else if(60<=h && h<120){ r1=X; g1=C; }
  else if(120<=h && h<180){ g1=C; b1=X; }
  else if(180<=h && h<240){ g1=X; b1=C; }
  else if(240<=h && h<300){ r1=X; b1=C; }
  else { r1=C; b1=X; }
  return [
    Math.round((r1+m)*255),
    Math.round((g1+m)*255),
    Math.round((b1+m)*255)
  ];
}
function rgbToHex(r,g,b){
  return "#" + [r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");
}
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  const r = parseInt(h.slice(0,2),16);
  const g = parseInt(h.slice(2,4),16);
  const b = parseInt(h.slice(4,6),16);
  return {r,g,b};
}

// ====== スポイト：中央値 ======
function medianColorAt(ctx2d, x, y, n, imgW, imgH){
  const half = Math.floor(n/2);
  const left = Math.max(0, x - half);
  const top  = Math.max(0, y - half);
  const right = Math.min(imgW, x + half);
  const bottom = Math.min(imgH, y + half);
  const w = Math.max(1, right - left);
  const h = Math.max(1, bottom - top);

  const data = ctx2d.getImageData(left, top, w, h).data;
  const rs=[], gs=[], bs=[];
  for(let i=0;i<data.length;i+=4){
    const a = data[i+3];
    if(a < 230) continue;
    rs.push(data[i]); gs.push(data[i+1]); bs.push(data[i+2]);
  }
  if(rs.length===0) return [128,128,128];
  rs.sort((a,b)=>a-b); gs.sort((a,b)=>a-b); bs.sort((a,b)=>a-b);
  const mid = Math.floor(rs.length/2);
  return [rs[mid], gs[mid], bs[mid]];
}

// ====== video→photo 撮影（正方形） ======
function drawVideoToPhotoSquare(targetSize=520){
  const vw = v.videoWidth, vh = v.videoHeight;
  if(!vw || !vh){
    picked.textContent = "カメラの準備中です（数秒待って再度）。";
    return null;
  }
  photo.width = targetSize;
  photo.height = targetSize;

  const side = Math.min(vw, vh);
  const sx = Math.floor(vw/2 - side/2);
  const sy = Math.floor(vh/2 - side/2);

  photoCtx.drawImage(v, sx, sy, side, side, 0, 0, targetSize, targetSize);
  return {w: targetSize, h: targetSize};
}

// ====== マーカー ======
function getDisplayRect(){
  const el = (viewMode === "freeze") ? photo : v;
  const r = el.getBoundingClientRect();
  return {w: r.width, h: r.height};
}
function resizeOverlayToMatchDisplay(){
  const rect = getDisplayRect();
  mark.width = Math.round(rect.w * devicePixelRatio);
  mark.height = Math.round(rect.h * devicePixelRatio);
  mctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
function clearMarker(){
  resizeOverlayToMatchDisplay();
  const rect = getDisplayRect();
  mctx.clearRect(0,0,rect.w,rect.h);
}
function drawMarker(x, y, w, h){
  resizeOverlayToMatchDisplay();
  const rect = getDisplayRect();
  mctx.clearRect(0,0,rect.w,rect.h);

  const px = (x / w) * rect.w;
  const py = (y / h) * rect.h;

  mctx.lineWidth = 2;
  mctx.strokeStyle = "rgba(255,255,255,0.9)";
  mctx.beginPath();
  mctx.moveTo(px-12, py); mctx.lineTo(px+12, py);
  mctx.moveTo(px, py-12); mctx.lineTo(px, py+12);
  mctx.stroke();

  const boxW = (SAMPLE_SIZE / w) * rect.w;
  const boxH = (SAMPLE_SIZE / h) * rect.h;
  mctx.strokeStyle = "rgba(255,255,255,0.6)";
  mctx.lineWidth = 1.5;
  mctx.strokeRect(px - boxW/2, py - boxH/2, boxW, boxH);
}

// ====== HTML escape ======
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (m) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[m]));
}
</script>
</body>
</html>