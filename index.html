<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Color Outfit Suggest (MVP)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:16px;}
    .wrap{position:relative; width:100%; max-width:520px;}
    video, canvas.display{width:100%; max-width:520px; border-radius:12px; background:#111; display:block;}
    canvas.overlay{position:absolute; inset:0; pointer-events:none; border-radius:12px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; align-items:center;}
    button{padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
    select{padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
    .hint{color:#555; font-size:13px; line-height:1.4; margin-top:6px;}
    .mini{color:#666; font-size:12px;}
    .swatch{width:150px; border-radius:12px; padding:10px; border:1px solid #ddd;}
    .chip{height:48px; border-radius:10px; border:1px solid rgba(0,0,0,.08);}
    .modeBadge{display:inline-block; padding:3px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; color:#444;}
  </style>
</head>
<body>
  <h2>撮影→スポイト色→配色提案（MVP）</h2>
  <div class="hint">
    ①「カメラ開始」→ライブ表示<br/>
    ②「撮影」→静止画を表示（その上でタップ＝スポイト）<br/>
    ③もう一度「撮影」→ライブ表示に戻る（次の撮影準備）<br/>
    ※TPOを変えると、<b>トーン（彩度/明度）を決め打ち</b>で提案色自体が変わります。
  </div>

  <div class="wrap">
    <video id="v" playsinline autoplay></video>
    <canvas id="photo" class="display"></canvas>
    <canvas id="mark" class="overlay"></canvas>
  </div>

  <div class="row">
    <button id="start">カメラ開始</button>
    <button id="snap">撮影</button>

    <select id="tpo">
      <option value="work">仕事</option>
      <option value="casual">休日</option>
      <option value="dinner">ディナー</option>
    </select>

    <span id="mode" class="modeBadge">未開始</span>
    <span id="picked" class="mini"></span>
  </div>

  <div id="out" class="row"></div>

<script>
const v = document.getElementById('v');
const photo = document.getElementById('photo');
const mark = document.getElementById('mark');

const out = document.getElementById('out');
const picked = document.getElementById('picked');
const modeBadge = document.getElementById('mode');
const tpoSel = document.getElementById('tpo');

const photoCtx = photo.getContext('2d', { willReadFrequently: true });
const mctx = mark.getContext('2d');

const SAMPLE_SIZE = 24; // スポイト領域 NxN

let viewMode = "live"; // live | freeze
let streamRef = null;

let currentTpo = "work";
tpoSel.value = currentTpo;

let lastBaseRgb = null;  // TPO変更時に再提案するため保持
let lastPick = null;     // 静止画上の座標

// 支配率は残す（要件どおり）
const TPO_WEIGHTS = {
  work:   [60, 18, 12,  4,  3,  3],
  casual: [45, 18, 12, 12,  7,  6],
  dinner: [35, 12,  8, 25, 10, 10],
};

// ====== トーン決め打ち（TPOごと） ======
// “提案色の見え方”を TPO で固定する（彩度/明度レンジを決め打ち）
const TONE_PRESET = {
  work: {
    name: "Muted / Middle",
    base:  { s:[0.10,0.35], l:[0.35,0.55] },
    same:  { s:[0.10,0.30], l:[0.35,0.55] },
    contra:{ s:[0.10,0.28], l:[0.35,0.55] }, // 対比も穏やか
    // 色相オフセット：同系×2 + 対比×3（補色を避け分割寄り）
    offsets: [0, +18, -18, +150, +165, +195]
  },
  casual: {
    name: "Medium / Flexible",
    base:  { s:[0.15,0.55], l:[0.30,0.70] },
    same:  { s:[0.15,0.55], l:[0.30,0.70] },
    contra:{ s:[0.25,0.65], l:[0.30,0.70] },
    // 王道：補色＋分割補色
    offsets: [0, +20, -20, +180, +150, +210]
  },
  dinner: {
    name: "Contrast / Night",
    base:  { s:[0.20,0.60], l:[0.25,0.55] }, // 夜は少し締める
    same:  { s:[0.20,0.55], l:[0.25,0.55] },
    contra:{ s:[0.45,0.85], l:[0.22,0.55] }, // 対比は強め
    // 補色＋トライアド（夜映え）
    offsets: [0, +30, -30, +180, +120, +240]
  }
};

function setMode(mode){
  viewMode = mode;
  if(mode === "live"){
    v.style.display = "block";
    photo.style.display = "none";
    modeBadge.textContent = "ライブ";
    clearMarker();
  }else{
    v.style.display = "none";
    photo.style.display = "block";
    modeBadge.textContent = "静止画";
    if(lastPick) drawMarker(lastPick.x, lastPick.y, photo.width, photo.height);
  }
}

photo.style.display = "none";
setMode("live");

// ====== カメラ開始 ======
document.getElementById('start').onclick = async () => {
  try{
    if(streamRef){
      setMode("live");
      picked.textContent = "カメラは起動済みです。";
      return;
    }
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" }, audio: false
    });
    streamRef = stream;
    v.srcObject = stream;
    await v.play(); // iOS対策
    setMode("live");
    picked.textContent = "カメラ起動中。撮影で静止画に固定できます。";
  }catch(err){
    picked.textContent = "カメラ開始に失敗: " + (err?.name ?? err);
    console.error(err);
  }
};

// ====== 撮影ボタン：live→freeze / freeze→live ======
document.getElementById('snap').onclick = () => {
  if(!streamRef){
    picked.textContent = "先に「カメラ開始」を押してください。";
    return;
  }

  if(viewMode === "live"){
    const info = drawVideoToPhotoSquare(520);
    if(!info) return;

    setMode("freeze");

    const x = lastPick ? lastPick.x : Math.floor(photo.width/2);
    const y = lastPick ? lastPick.y : Math.floor(photo.height/2);
    lastPick = {x, y};

    const base = medianColorAt(photoCtx, x, y, SAMPLE_SIZE, photo.width, photo.height);
    lastBaseRgb = base;

    const hex = rgbToHex(...base);
    picked.textContent = `採用: (${x},${y}) 周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${hex}`;

    drawMarker(x, y, photo.width, photo.height);

    const palette = suggestPaletteToneLocked(base, currentTpo);
    renderSwatches(palette, currentTpo);
  }else{
    setMode("live");
    picked.textContent = "ライブに戻りました。構図を決めて「撮影」で固定できます。";
  }
};

// ====== TPO変更：色そのものを作り直す ======
tpoSel.addEventListener('change', () => {
  currentTpo = tpoSel.value;
  if(lastBaseRgb){
    const palette = suggestPaletteToneLocked(lastBaseRgb, currentTpo);
    renderSwatches(palette, currentTpo);
  }
}, {passive:true});

// ====== 色変換 ======
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h=0, s=0, l=(max+min)/2;
  const d=max-min;
  if(d!==0){
    s = d / (1 - Math.abs(2*l - 1));
    switch(max){
      case r: h = ((g-b)/d) % 6; break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h *= 60; if(h<0) h+=360;
  }
  return [h,s,l];
}
function hslToRgb(h,s,l){
  const C = (1 - Math.abs(2*l - 1)) * s;
  const X = C * (1 - Math.abs((h/60)%2 - 1));
  const m = l - C/2;
  let r1=0,g1=0,b1=0;
  if(0<=h && h<60){ r1=C; g1=X; }
  else if(60<=h && h<120){ r1=X; g1=C; }
  else if(120<=h && h<180){ g1=C; b1=X; }
  else if(180<=h && h<240){ g1=X; b1=C; }
  else if(240<=h && h<300){ r1=X; b1=C; }
  else { r1=C; b1=X; }
  return [
    Math.round((r1+m)*255),
    Math.round((g1+m)*255),
    Math.round((b1+m)*255)
  ];
}
function rgbToHex(r,g,b){
  return "#" + [r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");
}

// ====== スポイト：中央値 ======
function medianColorAt(ctx2d, x, y, n, imgW, imgH){
  const half = Math.floor(n/2);
  const left = Math.max(0, x - half);
  const top  = Math.max(0, y - half);
  const right = Math.min(imgW, x + half);
  const bottom = Math.min(imgH, y + half);
  const w = Math.max(1, right - left);
  const h = Math.max(1, bottom - top);

  const data = ctx2d.getImageData(left, top, w, h).data;
  const rs=[], gs=[], bs=[];
  for(let i=0;i<data.length;i+=4){
    const a = data[i+3];
    if(a < 230) continue;
    rs.push(data[i]); gs.push(data[i+1]); bs.push(data[i+2]);
  }
  if(rs.length===0) return [128,128,128];
  rs.sort((a,b)=>a-b); gs.sort((a,b)=>a-b); bs.sort((a,b)=>a-b);
  const mid = Math.floor(rs.length/2);
  return [rs[mid], gs[mid], bs[mid]];
}

// ====== トーン決め打ち配色生成 ======
function toneLock(s, l, tone){
  const s2 = clamp(s, tone.s[0], tone.s[1]);
  const l2 = clamp(l, tone.l[0], tone.l[1]);
  return [s2, l2];
}

function suggestPaletteToneLocked(baseRgb, tpo){
  const preset = TONE_PRESET[tpo] ?? TONE_PRESET.work;
  const [h0,s0,l0] = rgbToHsl(...baseRgb);

  // BaseもTPOトーンに収める（＝TPOで“見え方”が変わる）
  let [bs, bl] = toneLock(s0, l0, preset.base);

  const mk = (label, h, s, l) => {
    const rgb = hslToRgb((h+360)%360, clamp01(s), clamp01(l));
    return { label, rgb, hex: rgbToHex(...rgb) };
  };

  // 同系は same トーンで固定
  const [sSame, lSame] = toneLock(s0, l0, preset.same);

  // 対比は contra トーンで固定
  const [sContra, lContra] = toneLock(s0, l0, preset.contra);

  const o = preset.offsets;

  return [
    mk("Base（拾った色）", h0 + o[0], bs, bl),
    mk("提案1（同系）",    h0 + o[1], sSame,  lSame),
    mk("提案2（同系）",    h0 + o[2], sSame,  lSame),
    mk("提案3（対比）",    h0 + o[3], sContra, lContra),
    mk("提案4（対比）",    h0 + o[4], sContra, lContra),
    mk("提案5（対比）",    h0 + o[5], sContra, lContra),
  ];
}

function renderSwatches(items, tpo){
  const weights = TPO_WEIGHTS[tpo] ?? TPO_WEIGHTS.work;
  const toneName = (TONE_PRESET[tpo]?.name ?? "");

  out.innerHTML = "";
  items.forEach((it, idx) => {
    const w = weights[idx] ?? 0;
    const div = document.createElement('div');
    div.className = "swatch";
    div.innerHTML = `
      <div class="chip" style="background:${it.hex}"></div>
      <div style="margin-top:8px;font-size:13px;">
        ${it.label} <b>${w}%</b>
      </div>
      <div style="color:#555;font-size:12px;">${it.hex}</div>
      ${idx===0 ? `<div style="margin-top:6px;color:#666;font-size:12px;">Tone: ${toneName}</div>` : ``}
    `;
    out.appendChild(div);
  });
}

// ====== video→photo 撮影（正方形） ======
function drawVideoToPhotoSquare(targetSize=520){
  const vw = v.videoWidth, vh = v.videoHeight;
  if(!vw || !vh){
    picked.textContent = "カメラの準備中です（数秒待って再度）。";
    return null;
  }
  photo.width = targetSize;
  photo.height = targetSize;

  const side = Math.min(vw, vh);
  const sx = Math.floor(vw/2 - side/2);
  const sy = Math.floor(vh/2 - side/2);

  photoCtx.drawImage(v, sx, sy, side, side, 0, 0, targetSize, targetSize);
  return {w: targetSize, h: targetSize};
}

// ====== マーカー ======
function getDisplayRect(){
  const el = (viewMode === "freeze") ? photo : v;
  const r = el.getBoundingClientRect();
  return {w: r.width, h: r.height};
}
function resizeOverlayToMatchDisplay(){
  const rect = getDisplayRect();
  mark.width = Math.round(rect.w * devicePixelRatio);
  mark.height = Math.round(rect.h * devicePixelRatio);
  mctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
function clearMarker(){
  resizeOverlayToMatchDisplay();
  const rect = getDisplayRect();
  mctx.clearRect(0,0,rect.w,rect.h);
}
function drawMarker(x, y, w, h){
  resizeOverlayToMatchDisplay();
  const rect = getDisplayRect();

  mctx.clearRect(0,0,rect.w,rect.h);

  const px = (x / w) * rect.w;
  const py = (y / h) * rect.h;

  mctx.lineWidth = 2;
  mctx.strokeStyle = "rgba(255,255,255,0.9)";
  mctx.beginPath();
  mctx.moveTo(px-12, py); mctx.lineTo(px+12, py);
  mctx.moveTo(px, py-12); mctx.lineTo(px, py+12);
  mctx.stroke();

  const boxW = (SAMPLE_SIZE / w) * rect.w;
  const boxH = (SAMPLE_SIZE / h) * rect.h;
  mctx.strokeStyle = "rgba(255,255,255,0.6)";
  mctx.lineWidth = 1.5;
  mctx.strokeRect(px - boxW/2, py - boxH/2, boxW, boxH);
}

// ====== スポイト：静止画上のみ ======
photo.addEventListener('pointerdown', (e) => {
  if(viewMode !== "freeze") return;

  const rect = photo.getBoundingClientRect();
  const rx = clamp01((e.clientX - rect.left) / rect.width);
  const ry = clamp01((e.clientY - rect.top) / rect.height);

  const x = Math.round(rx * (photo.width - 1));
  const y = Math.round(ry * (photo.height - 1));

  lastPick = {x, y};

  const base = medianColorAt(photoCtx, x, y, SAMPLE_SIZE, photo.width, photo.height);
  lastBaseRgb = base;

  const hex = rgbToHex(...base);
  picked.textContent = `スポイト: (${x},${y}) 周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${hex}`;

  drawMarker(x, y, photo.width, photo.height);

  const palette = suggestPaletteToneLocked(base, currentTpo);
  renderSwatches(palette, currentTpo);
}, {passive:true});

window.addEventListener('resize', () => {
  if(viewMode === "freeze" && lastPick){
    drawMarker(lastPick.x, lastPick.y, photo.width, photo.height);
  }else{
    clearMarker();
  }
}, {passive:true});
</script>
</body>
</html>