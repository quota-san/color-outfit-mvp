<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Color Outfit Suggest (MVP)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:16px;}
    video,canvas{width:100%; max-width:520px; border-radius:12px; background:#111;}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; align-items:center;}
    .swatch{width:140px; border-radius:12px; padding:10px; border:1px solid #ddd;}
    .chip{height:48px; border-radius:10px; border:1px solid rgba(0,0,0,.08);}
    button{padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
    select{padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff;}
    .hint{color:#555; font-size:13px; line-height:1.4;}
    .mini{color:#666; font-size:12px;}
    .wrap{position:relative; width:100%; max-width:520px;}
    .overlay{
      position:absolute; inset:0; pointer-events:none;
      border-radius:12px;
    }
  </style>
</head>
<body>
  <h2>撮影→スポイト色→配色提案（MVP）</h2>
  <p class="hint">
    黒い枠（プレビュー）を<b>タップ</b>すると、その地点の周辺色で提案します。<br/>
    代表色は周辺領域の<b>RGB中央値</b>（反射・影にやや強め）。
  </p>

  <div class="wrap">
    <video id="v" playsinline autoplay></video>
    <canvas id="mark" class="overlay"></canvas>
  </div>

  <div class="row">
    <button id="start">カメラ開始</button>
    <button id="snap">撮影</button>

    <select id="tpo">
      <option value="work">仕事</option>
      <option value="casual">休日</option>
      <option value="dinner">ディナー</option>
    </select>

    <span id="picked" class="mini"></span>
  </div>

  <canvas id="c" width="520" height="520" style="display:none;"></canvas>
  <div id="out" class="row"></div>

<script>
const v = document.getElementById('v');
const c = document.getElementById('c');
const ctx = c.getContext('2d', { willReadFrequently: true });

const mark = document.getElementById('mark');
const mctx = mark.getContext('2d');

const out = document.getElementById('out');
const picked = document.getElementById('picked');
const tpoSel = document.getElementById('tpo');

// どれくらいの範囲で色を拾うか（NxN）。20でもOK。偶数だと扱いやすい
const SAMPLE_SIZE = 24;

// 最後にユーザーがタップした座標（canvas座標 0..w-1）
let lastPick = null;

// TPO別：6色の支配率（合計100%）
// 並びは suggestPalette() の返り値と一致：
// [0]=Base, [1]=SameA, [2]=SameB, [3]=Comp, [4]=SplitA, [5]=SplitB
const TPO_PRESETS = {
  work:   [60, 18, 12,  4,  3,  3],
  casual: [45, 18, 12, 12,  7,  6],
  dinner: [35, 12,  8, 25, 10, 10],
};
let currentTpo = "work";
tpoSel.value = currentTpo;
tpoSel.addEventListener('change', () => {
  currentTpo = tpoSel.value;
  if (window.__lastPalette) renderSwatches(window.__lastPalette);
});

document.getElementById('start').onclick = async () => {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment" }, audio: false
  });
  v.srcObject = stream;
};

function clamp01(x){ return Math.max(0, Math.min(1, x)); }

// sRGB <-> HSL（簡易）
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h=0, s=0, l=(max+min)/2;
  const d=max-min;
  if(d!==0){
    s = d / (1 - Math.abs(2*l - 1));
    switch(max){
      case r: h = ((g-b)/d) % 6; break;
      case g: h = (b-r)/d + 2; break;
      case b: h = (r-g)/d + 4; break;
    }
    h *= 60; if(h<0) h+=360;
  }
  return [h,s,l];
}
function hslToRgb(h,s,l){
  const C = (1 - Math.abs(2*l - 1)) * s;
  const X = C * (1 - Math.abs((h/60)%2 - 1));
  const m = l - C/2;
  let r1=0,g1=0,b1=0;
  if(0<=h && h<60){ r1=C; g1=X; }
  else if(60<=h && h<120){ r1=X; g1=C; }
  else if(120<=h && h<180){ g1=C; b1=X; }
  else if(180<=h && h<240){ g1=X; b1=C; }
  else if(240<=h && h<300){ r1=X; b1=C; }
  else { r1=C; b1=X; }
  const r=Math.round((r1+m)*255), g=Math.round((g1+m)*255), b=Math.round((b1+m)*255);
  return [r,g,b];
}
function rgbToHex(r,g,b){
  return "#" + [r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");
}

// 領域NxNのRGB「中央値」で代表色を求める（反射/影に少し強い）
function medianColorAt(x, y, n, imgW, imgH){
  const half = Math.floor(n/2);

  const left = Math.max(0, x - half);
  const top  = Math.max(0, y - half);
  const right = Math.min(imgW, x + half);
  const bottom = Math.min(imgH, y + half);

  const w = Math.max(1, right - left);
  const h = Math.max(1, bottom - top);

  const data = ctx.getImageData(left, top, w, h).data;

  const rs = [];
  const gs = [];
  const bs = [];

  for(let i=0;i<data.length;i+=4){
    const a = data[i+3];
    if(a < 230) continue;
    rs.push(data[i]);
    gs.push(data[i+1]);
    bs.push(data[i+2]);
  }

  if(rs.length === 0) return [128,128,128];

  rs.sort((a,b)=>a-b);
  gs.sort((a,b)=>a-b);
  bs.sort((a,b)=>a-b);
  const mid = Math.floor(rs.length/2);
  return [rs[mid], gs[mid], bs[mid]];
}

// 配色候補：同系色 / 差し色（補色） / 分割補色
function suggestPalette(baseRgb){
  const [h,s,l] = rgbToHsl(...baseRgb);

  // 同系（左右）
  const same1 = [ (h+20)%360, s, l ];
  const same2 = [ (h+340)%360, s, l ];

  // 補色
  const comp  = [ (h+180)%360, s, l ];

  // 分割補色
  const split1 = [ (h+150)%360, s, l ];
  const split2 = [ (h+210)%360, s, l ];

  return [
    {label:"Base（拾った色）", hsl:[h,s,l]},
    {label:"同系色A", hsl:same1},
    {label:"同系色B", hsl:same2},
    {label:"補色",   hsl:comp},
    {label:"分割補色A", hsl:split1},
    {label:"分割補色B", hsl:split2},
  ].map(x=>{
    const rgb = hslToRgb(...x.hsl);
    return {...x, rgb, hex: rgbToHex(...rgb)};
  });
}

function renderSwatches(items){
  window.__lastPalette = items;
  const weights = TPO_PRESETS[currentTpo] ?? TPO_PRESETS.work;

  out.innerHTML = "";
  items.forEach((it, idx) => {
    const w = weights[idx] ?? 0;

    const div = document.createElement('div');
    div.className = "swatch";
    div.innerHTML = `
      <div class="chip" style="background:${it.hex}"></div>
      <div style="margin-top:8px;font-size:13px;">
        ${it.label} <b>${w}%</b>
      </div>
      <div style="color:#555;font-size:12px;">${it.hex}</div>
    `;
    out.appendChild(div);
  });
}

// マーカー描画（十字＋サンプル枠）
function drawMarker(x, y, w, h){
  // overlay canvas を video と同じ表示サイズに合わせる
  const rect = v.getBoundingClientRect();
  mark.width = Math.round(rect.width * devicePixelRatio);
  mark.height = Math.round(rect.height * devicePixelRatio);
  mctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);

  mctx.clearRect(0,0,rect.width,rect.height);

  // video表示座標へ変換
  const px = (x / w) * rect.width;
  const py = (y / h) * rect.height;

  // 十字
  mctx.lineWidth = 2;
  mctx.strokeStyle = "rgba(255,255,255,0.9)";
  mctx.beginPath();
  mctx.moveTo(px-12, py); mctx.lineTo(px+12, py);
  mctx.moveTo(px, py-12); mctx.lineTo(px, py+12);
  mctx.stroke();

  // サンプル枠（N×Nを表示比に換算した大きさ）
  const boxW = (SAMPLE_SIZE / w) * rect.width;
  const boxH = (SAMPLE_SIZE / h) * rect.height;

  mctx.strokeStyle = "rgba(255,255,255,0.6)";
  mctx.lineWidth = 1.5;
  mctx.strokeRect(px - boxW/2, py - boxH/2, boxW, boxH);
}

// videoの現在フレームを canvas に正方形で描画
function drawVideoToCanvasSquare(targetSize=520){
  const vw = v.videoWidth, vh = v.videoHeight;
  if(!vw || !vh) return null;

  c.width = targetSize;
  c.height = targetSize;

  const side = Math.min(vw, vh);
  const sx = Math.floor(vw/2 - side/2);
  const sy = Math.floor(vh/2 - side/2);

  ctx.drawImage(v, sx, sy, side, side, 0, 0, targetSize, targetSize);
  return {w: targetSize, h: targetSize};
}

// タップでスポイト位置を決める
v.addEventListener('click', () => {
  // いま表示されているフレームを一度canvasへ描いて、座標系を統一
  const info = drawVideoToCanvasSquare(520);
  if(!info) return;

  const rect = v.getBoundingClientRect();
  const evt = window.event;
  const clientX = evt.clientX ?? 0;
  const clientY = evt.clientY ?? 0;

  const rx = clamp01((clientX - rect.left) / rect.width);
  const ry = clamp01((clientY - rect.top) / rect.height);

  const x = Math.round(rx * (info.w - 1));
  const y = Math.round(ry * (info.h - 1));

  lastPick = {x, y};

  const base = medianColorAt(x, y, SAMPLE_SIZE, info.w, info.h);
  const hex = rgbToHex(...base);
  picked.textContent = `スポイト: (${x},${y})  周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${hex}`;

  drawMarker(x, y, info.w, info.h);

  const palette = suggestPalette(base);
  renderSwatches(palette);
}, {passive:true});

// iOSで click が取りにくい場合の保険（touch）
v.addEventListener('touchend', (e) => {
  if(!e.changedTouches || e.changedTouches.length === 0) return;
  const t = e.changedTouches[0];

  const info = drawVideoToCanvasSquare(520);
  if(!info) return;

  const rect = v.getBoundingClientRect();
  const rx = clamp01((t.clientX - rect.left) / rect.width);
  const ry = clamp01((t.clientY - rect.top) / rect.height);

  const x = Math.round(rx * (info.w - 1));
  const y = Math.round(ry * (info.h - 1));

  lastPick = {x, y};

  const base = medianColorAt(x, y, SAMPLE_SIZE, info.w, info.h);
  const hex = rgbToHex(...base);
  picked.textContent = `スポイト: (${x},${y})  周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${hex}`;

  drawMarker(x, y, info.w, info.h);

  const palette = suggestPalette(base);
  renderSwatches(palette);
}, {passive:true});

// 撮影ボタン：最後のスポイト位置（なければ中心）で色を拾う
document.getElementById('snap').onclick = () => {
  const info = drawVideoToCanvasSquare(520);
  if(!info) return;

  const x = lastPick ? lastPick.x : Math.floor(info.w/2);
  const y = lastPick ? lastPick.y : Math.floor(info.h/2);

  const base = medianColorAt(x, y, SAMPLE_SIZE, info.w, info.h);
  const hex = rgbToHex(...base);

  picked.textContent = `採用: (${x},${y})  周辺${SAMPLE_SIZE}×${SAMPLE_SIZE} 中央値 ${hex}`;
  drawMarker(x, y, info.w, info.h);

  const palette = suggestPalette(base);
  renderSwatches(palette);
};

// リサイズ時にマーカーがズレるのを軽減（最後の座標で描き直し）
window.addEventListener('resize', () => {
  if(!lastPick) return;
  // 直近フレームがないと描けないので、snap相当で再描画
  const info = drawVideoToCanvasSquare(520);
  if(!info) return;
  drawMarker(lastPick.x, lastPick.y, info.w, info.h);
}, {passive:true});
</script>
</body>
</html>